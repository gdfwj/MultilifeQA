{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-24 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-24 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-22 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-22 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-13 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-13 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-02 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-02 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-15 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-15 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-29 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-29 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-29 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-29 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-07 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-07 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-16 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-16 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-23 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-23 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-07 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-07 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-17 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-17 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-21 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-21 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-13 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-13 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-26 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-26 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-22 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-22 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-19 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-19 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-05 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-05 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-08 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-08 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-06 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-06 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-21 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-21 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-05 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-05 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-25 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-25 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-28 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-28 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-14 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-14 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-05-27 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-05-27 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-16 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-16 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-04 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-04 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-22 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-22 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users on 2022-06-02 the same as the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users on 2022-06-02 the same as the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-14 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-14 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-18 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-18 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-24 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-24 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-31 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-31 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-11 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-11 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-15 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-15 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-03 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-03 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-29 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-29 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-10 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-10 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-01 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-01 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-12 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-12 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-22 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-22 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-02 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-18 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-18 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-08 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-08 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-13 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-13 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-21 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-21 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-11 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-11 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-13 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-13 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-20 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-05-28 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid the most frequent cooking_style across all users change on 2022-06-04 compared to the previous day?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did the most frequent cooking_style across all users change on 2022-06-04 compared to the previous day?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-30, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-30, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-08, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-08, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-15, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-15, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-26, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-26, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-16, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-16, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-13, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-13, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-17, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-17, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-22, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-22, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-07, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-07, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-15, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-15, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-05, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-05, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-08, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-08, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-04, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-04, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-21, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-21, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-20, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-20, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-09, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-09, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-06, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-06, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-27, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-27, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-19, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-19, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-20, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-20, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-12, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-12, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-14, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-14, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-23, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-06-02, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWas the most common category across all users the same within one week, starting from 2022-05-31, compared to the previous week?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Was the most common category across all users the same within one week, starting from 2022-05-31, compared to the previous week?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_60728 consume the same subcategory 'Poultry', starting from 2022-06-08?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_60728 consume the same subcategory 'Poultry', starting from 2022-06-08?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_45863 consume the same subcategory 'Cured Meats and Cold Cuts', starting from 2022-05-24?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_45863 consume the same subcategory 'Cured Meats and Cold Cuts', starting from 2022-05-24?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_85240 consume the same subcategory 'Eggs', starting from 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_85240 consume the same subcategory 'Eggs', starting from 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_99000 consume the same subcategory 'Infusions (Coffee and Others)', starting from 2022-06-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_99000 consume the same subcategory 'Infusions (Coffee and Others)', starting from 2022-06-17?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "3"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_76383 consume the same subcategory 'Infusions (Coffee and Others)', starting from 2022-05-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_76383 consume the same subcategory 'Infusions (Coffee and Others)', starting from 2022-05-19?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "14"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_79824 consume the same subcategory 'Processed Dairy', starting from 2022-06-10?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_79824 consume the same subcategory 'Processed Dairy', starting from 2022-06-10?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "4"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_82994 consume the same subcategory 'Sugary Dairy Shakes', starting from 2022-06-07?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_82994 consume the same subcategory 'Sugary Dairy Shakes', starting from 2022-06-07?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_73455 consume the same subcategory 'Processed Dairy', starting from 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_73455 consume the same subcategory 'Processed Dairy', starting from 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_45118 consume the same subcategory 'Vegetables and Greens', starting from 2022-05-26?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_45118 consume the same subcategory 'Vegetables and Greens', starting from 2022-05-26?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "3"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_93973 consume the same subcategory 'Fruits', starting from 2022-06-09?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_93973 consume the same subcategory 'Fruits', starting from 2022-06-09?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "11"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_42312 consume the same subcategory 'Fruits', starting from 2022-05-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_42312 consume the same subcategory 'Fruits', starting from 2022-05-22?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "7"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_67598 consume the same subcategory 'Fish', starting from 2022-05-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_67598 consume the same subcategory 'Fish', starting from 2022-05-22?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nHow many consecutive days did A4F_84740 consume the same subcategory 'Fruits', starting from 2022-05-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: How many consecutive days did A4F_84740 consume the same subcategory 'Fruits', starting from 2022-05-22?\nOutput requirement: return 1 value(s); types (ordered): {integer}", "Answer": "2"}
