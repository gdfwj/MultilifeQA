{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-31?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-31?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_56297"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-21?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_10660"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-04?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-04?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_24211"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-26?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-26?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_13368"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-17?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_89897"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-21?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_10660"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2014-07-27?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2014-07-27?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_22483"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-18?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-18?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_29474"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_89897"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-07?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-07?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_22483"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-01?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-01?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_28771"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_98453"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-31?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-31?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_56297"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-23?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_44160"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-20?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_13504"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-07?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-07?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_22483"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-23?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_44160"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-22?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_13504"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2014-07-27?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2014-07-27?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_22483"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-17?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_22483"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-18?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-18?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_76292"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-15?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-15?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_31033"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-04?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-04?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_24211"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-08?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-08?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_79824"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-12?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-12?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_29474"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-12?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-12?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_29474"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_98453"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-12?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-12?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_29474"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-05-24?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-05-24?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_33497"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhich user consumed the most different categories of food on 2022-06-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Which user consumed the most different categories of food on 2022-06-21?\nOutput requirement: return 1 value(s); types (ordered): {uid}", "Answer": "A4F_10660"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-11?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-11?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-14?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-14?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-08?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-08?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-30?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-30?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-01?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-01?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-11?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-11?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-28?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-28?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Alcoholic Beverages"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-19?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-23?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-01?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-01?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-16?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-16?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-15?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-15?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Alcoholic Beverages"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-15?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-15?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-03?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-03?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-05?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-05?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-20?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-30?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-30?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-31?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-31?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-19?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-20?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fruits"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-17?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-09?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-09?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-06-06?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-06-06?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most common subcategory of food across all users on 2022-05-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most common subcategory of food across all users on 2022-05-17?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Vegetables and Greens"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fermented"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-21?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-20?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-27?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-27?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-17?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-25?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-25?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-19?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-26?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-26?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-29?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-29?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-11?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-11?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-27?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-27?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-28?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-28?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-10?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-10?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-21?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-05?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-05?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-06?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-06?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-08?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-08?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-28?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-28?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-11?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-11?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fermented"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-10?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-10?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-06?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-06?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-19?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-10?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-10?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-05-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-05-21?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-06?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-06?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-10?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-10?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nWhat was the most frequent cooking_style across all users on 2022-06-05?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: What was the most frequent cooking_style across all users on 2022-06-05?\nOutput requirement: return 1 value(s); types (ordered): {word}", "Answer": "Fresh"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_45863 consume multiple categories of food on 2022-06-04?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_45863 consume multiple categories of food on 2022-06-04?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_32988 consume multiple categories of food on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_32988 consume multiple categories of food on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_93973 consume multiple categories of food on 2022-06-19?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_93973 consume multiple categories of food on 2022-06-19?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_56355 consume multiple categories of food on 2022-06-02?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_56355 consume multiple categories of food on 2022-06-02?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_41207 consume multiple categories of food on 2022-05-24?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_41207 consume multiple categories of food on 2022-05-24?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_28689 consume multiple categories of food on 2022-06-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_28689 consume multiple categories of food on 2022-06-17?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_67757 consume multiple categories of food on 2022-06-01?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_67757 consume multiple categories of food on 2022-06-01?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_94601 consume multiple categories of food on 2022-06-06?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_94601 consume multiple categories of food on 2022-06-06?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_13504 consume multiple categories of food on 2022-06-23?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_13504 consume multiple categories of food on 2022-06-23?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_27766 consume multiple categories of food on 2022-06-15?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_27766 consume multiple categories of food on 2022-06-15?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_27766 consume multiple categories of food on 2022-06-07?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_27766 consume multiple categories of food on 2022-06-07?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_65060 consume multiple categories of food on 2022-05-26?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_65060 consume multiple categories of food on 2022-05-26?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_62344 consume multiple categories of food on 2022-06-05?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_62344 consume multiple categories of food on 2022-06-05?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_98040 consume multiple categories of food on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_98040 consume multiple categories of food on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_85240 consume multiple categories of food on 2022-06-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_85240 consume multiple categories of food on 2022-06-22?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_20573 consume multiple categories of food on 2022-05-25?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_20573 consume multiple categories of food on 2022-05-25?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_94601 consume multiple categories of food on 2022-05-18?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_94601 consume multiple categories of food on 2022-05-18?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_43794 consume multiple categories of food on 2022-05-31?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_43794 consume multiple categories of food on 2022-05-31?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_98453 consume multiple categories of food on 2022-06-18?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_98453 consume multiple categories of food on 2022-06-18?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_84534 consume multiple categories of food on 2022-05-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_84534 consume multiple categories of food on 2022-05-17?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_48857 consume multiple categories of food on 2022-06-02?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_48857 consume multiple categories of food on 2022-06-02?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_65060 consume multiple categories of food on 2022-05-18?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_65060 consume multiple categories of food on 2022-05-18?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_27766 consume multiple categories of food on 2022-05-17?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_27766 consume multiple categories of food on 2022-05-17?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_56297 consume multiple categories of food on 2022-06-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_56297 consume multiple categories of food on 2022-06-20?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_92332 consume multiple categories of food on 2022-05-20?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_92332 consume multiple categories of food on 2022-05-20?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_86472 consume multiple categories of food on 2022-06-04?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_86472 consume multiple categories of food on 2022-06-04?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_73455 consume multiple categories of food on 2022-05-21?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_73455 consume multiple categories of food on 2022-05-21?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "yes"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_84740 consume multiple categories of food on 2022-06-05?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_84740 consume multiple categories of food on 2022-06-05?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_24211 consume multiple categories of food on 2022-06-02?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_24211 consume multiple categories of food on 2022-06-02?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
{"Query_sql": "Given the following MySQL table schema, write ONE SELECT statement to compute the data you need. Use DATE(ts) for date filtering if needed. Output SQL only.\n\nQuestion:\nDid A4F_10355 consume multiple categories of food on 2022-05-22?\n\nSchema (DDL):\n```sql\nCREATE TABLE `food_meal_labels` (\n  `id`            VARCHAR(20)   NOT NULL,\n  `ts`            DATETIME      NOT NULL,\n  `image_id`      VARCHAR(100)  NOT NULL,\n  `category`      VARCHAR(128)  NOT NULL,\n  `subcategory`   VARCHAR(128)  NOT NULL,\n  `cooking_style` VARCHAR(128)  NOT NULL,\n  PRIMARY KEY (`id`,`ts`,`image_id`,`category`,`subcategory`,`cooking_style`),\n  KEY `idx_id_ts` (`id`,`ts`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n-- Semantics:\n--   * Deduplicate within a meal (id, ts, label).\n--   * For \"times\" counts across a day/week, count distinct meals (ts) that include the label.\n--     A safe pattern is to build a meal-dedup CTE:\n--       WITH m AS (\n--         SELECT DISTINCT id, ts, DATE(ts) AS d, category, subcategory, cooking_style\n--         FROM food_meal_labels\n--       )\n--     Then aggregate on m.\n\n```", "Query_base": "You will be given the SQL result for the question. Answer the question based on the SQL result, do not include explanations. \nQuestion: Did A4F_10355 consume multiple categories of food on 2022-05-22?\nOutput requirement: return 1 value(s); types (ordered): {yes or no}", "Answer": "no"}
